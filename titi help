#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <float.h>
#include <limits.h>
#define REALOCSIZE 256
#ifndef CDATAFRAME_CDATAFRAME_H
#define CDATAFRAME_CDATAFRAME_H

enum enum_type
{
    NULLVAL = 1 , UINT, INT, CHAR, FLOAT, DOUBLE, STRING, STRUCTURE
};
typedef enum enum_type ENUM_TYPE;

union column_type{
    unsigned int uint_value;
    signed int int_value;
    char char_value;
    float float_value;
    double double_value;
    char* string_value;
    void* struct_value;
};
typedef union column_type COL_TYPE ;

struct column {
    char *title;
    unsigned int size; //logical size
    unsigned int max_size; //physical size
    ENUM_TYPE column_type;
    COL_TYPE **data; // array of pointers to stored data
    unsigned long long int *index; // array of integers
};
typedef struct column COLUMN;

COLUMN *create_column(ENUM_TYPE type, char *title);

int insert_value(COLUMN *col, void *value, unsigned int index);

void delete_column(COLUMN **col);

void convert_value(COLUMN *col, unsigned long long int i, char *str, int size);

void print_col(COLUMN* col);

COL_TYPE get_value_at(COLUMN *col, unsigned int x);

int count_values_less_than(COLUMN *col, COL_TYPE x);

int count_values_equal_to(COLUMN *col, COL_TYPE x);

COLUMN** create_empty_CDataframe();

void remplissage_utilisateur(COLUMN **CDataframe, int nombre_de_colonnes);

void remplissage_dur(COLUMN **CDataframe, int nombre_de_colonnes);

void fill_empty_cells(COLUMN** CDataframe, int nombre_de_colonnes);

void print_DataFrame(COLUMN **CDataframe, int nombre_de_colonnes);

void print_partial_row_data(COLUMN** CDataframe, int nombre_de_colonnes, int start_index, int end_index);

void print_partial_column_data(COLUMN **CDataframe, int nombre_de_colonnes, int start_index, int end_index);

void delete_row(COLUMN** CDataframe, int nombre_de_colonnes, int index);

void add_row(COLUMN** CDataframe, int nombre_de_colonnes, void** values);

int max_logical_size(COLUMN **CDataframe, int nombre_de_colonnes);

void add_column(COLUMN*** CDataframe, int* nombre_de_colonnes, char* title, ENUM_TYPE type);

void delete_column_CDataframe(COLUMN*** CDataframe, int* nombre_de_colonnes, int index);

void rename_column(COLUMN** CDataframe, int nombre_de_colonnes, int index, char* new_title);

int value_exists_in_column(COLUMN* column, void* value);

int value_exists_in_CDataframe(COLUMN** CDataframe, int nombre_de_colonnes, void* value);

#endif //CDATAFRAME_CDATAFRAME_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "test.h"
#define OUI 0
#define NON 1

int main(void)
{
    COLUMN **CDataframe = create_empty_CDataframe();

    int *nombre_de_colonnes = malloc(sizeof(int));
    printf("Entrer le nombre de colonnes du DataFrame ");
    scanf("%d", nombre_de_colonnes);

    CDataframe = malloc(*nombre_de_colonnes * sizeof(COLUMN *));

    printf("\n");
    int choix;
    printf("Voulez vous un remplissage avec vos valeurs (1) ou un remplissage automatique(2) ? ");
    scanf("%d", &choix);
    while (choix != 1 && choix != 2)
    {
        printf("Choisissez (1) ou (2) ? ");
        scanf("%d", &choix);
    }
    if (choix == 1)
        remplissage_utilisateur(CDataframe, *nombre_de_colonnes);
    else
        remplissage_dur(CDataframe, *nombre_de_colonnes);
    print_DataFrame(CDataframe,*nombre_de_colonnes);
    printf("test");
}


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#include <time.h>
#define MAX_STRING_LENGTH 100 // Longueur maximale des chaînes de caractères générées
#include "test.h"

COLUMN* create_column( ENUM_TYPE type, char* title)
{
    COLUMN* new_column = (COLUMN*)malloc(sizeof(COLUMN));
    if (new_column == NULL) {
        return NULL; // Allocation failed
    }

    new_column->title = strdup(title); // Copy title string
    if (new_column->title == NULL) {
        free(new_column);
        return NULL; // Allocation failed
    }

    new_column->size = 0; // Initialize logical size
    new_column->max_size = 0; // Set physical size
    new_column->column_type = type; // Set column type
    new_column->data = NULL; // Initialize data pointer to NUnew_column->index = NULL; // Initialize index pointer to NULL

    return new_column; // Return pointer to the newly created column
}

int insert_value(COLUMN *col, void *value, unsigned int index)
{
    if (col == NULL) {
        return 0; // Colonne invalide
    }

    // Vérifier si l'index est valide
    if (index < 0 || index > col->size) {
        return 0; // Index invalide
    }

    // Allouer de l'espace mémoire si nécessaire
    if (col->size == col->max_size || col->max_size == 0) {
        int new_size = col->max_size + REALOCSIZE;
        void* new_data = realloc(col->data, new_size * sizeof(COL_TYPE*));
        if (new_data == NULL) {
            return 0; // Échec de réallocation mémoire
        }
        col->data = new_data;
        col->max_size = new_size;
    }

    // Déplacer les valeurs pour faire de la place pour la nouvelle valeur
    for (int i = col->size; i > index; i--) {
        col->data[i] = col->data[i-1];
    }

    // Copier la valeur dans la colonne à l'index spécifié
    switch (col->column_type) {
        case UINT:
            *((unsigned int*)(col->data[index])) = *((unsigned int*)value);
            break;
        case INT:
            *((signed int*)(col->data[index])) = *((signed int*)value);
            break;
        case CHAR:
            *((char*)(col->data[index])) = *((char*)value);
            break;
        case FLOAT:
            *((float*)(col->data[index])) = *((float*)value);
            break;
        case DOUBLE:
            *((double*)(col->data[index])) = *((double*)value);
            break;
        case STRING:
            *((char**)(col->data[index])) = strdup((char*)value);
            if (*((char**)(col->data[index])) == NULL) {
                return 0; // Échec d'allocation mémoire
            }
            break;
        case STRUCTURE:
            *((void**)(col->data[index])) = value;
            break;
        default:
            return 0; // Type de données non pris en charge
    }

    ++col->size;
    return 1; // Insertion réussie
}


void delete_column(COLUMN **col)
{
    if (col == NULL || *col == NULL) {
        return; // Rien à libérer
    }

    // Libérer l'espace mémoire alloué pour le titre de la colonne
    free((*col)->title);
    (*col)->title = NULL;

    // Libérer l'espace mémoire alloué pour les données de la colonne
    if ((*col)->data != NULL) {
        for (unsigned int i = 0; i < (*col)->size; ++i) {
            switch ((*col)->column_type) {
                case STRING:
                    free((*col)->data[i]->string_value);
                    break;
                default:
                    break;
            }
            free((*col)->data[i]);
        }
        free((*col)->data);
        (*col)->data = NULL;
    }

    // Libérer l'espace mémoire alloué pour l'index de la colonne
    free((*col)->index);
    (*col)->index = NULL;

    // Libérer l'espace mémoire alloué pour la structure de colonne
    free(*col);
    *col = NULL;
}

void convert_value(COLUMN *col, unsigned long long int i, char *str, int size)
{
    if (col == NULL || str == NULL || i >= col->size) {
        return; // Colonne invalide ou indice hors limites
    }

    // Convertir la valeur en chaîne de caractères en fonction du type de la colonne
    switch (col->column_type) {
        case UINT:
            snprintf(str, size, "%u", col->data[i]->uint_value);
            break;
        case INT:
            snprintf(str, size, "%d", col->data[i]->int_value);
            break;
        case CHAR:
            snprintf(str, size, "%c", col->data[i]->char_value);
            break;
        case FLOAT:
            snprintf(str, size, "%f", col->data[i]->float_value);
            break;
        case DOUBLE:
            snprintf(str, size, "%lf", col->data[i]->double_value);
            break;
        case STRING:
            strncpy(str, col->data[i]->string_value, size - 1);
            str[size - 1] = '\0'; // Assurer la terminaison de la chaîne
            break;
        case STRUCTURE:
            strncpy(str, "STRUCTURE", size - 1);
            str[size - 1] = '\0'; // Assurer la terminaison de la chaîne
            break;
        default:
            strncpy(str, "UNKNOWN", size - 1);
            str[size - 1] = '\0'; // Assurer la terminaison de la chaîne
            break;
    }
}

void print_col(COLUMN* col)
{
    if (col == NULL) {
        printf("Column is NULL\n");
        return;
    }

    printf("Title: %s\n", col->title);
    printf("Column type: %d\n", col->column_type);
    printf("Size: %u\n", col->size);
    printf("Max size: %u\n", col->max_size);

    printf("Content:\n");
    for (unsigned int i = 0; i < col->size; ++i) {
        char value_str[256]; // Taille arbitraire pour stocker la valeur convertie en chaîne
        convert_value(col, i, value_str, sizeof(value_str));
        printf("[%u] %s\n", i, value_str);
    }
}

int occurences(void* x, COLUMN *col)
{
    int occurence = 0;
    if (col != NULL && col->data != NULL)
    {
        switch (col->column_type)
        {
            case STRUCTURE:
                for (int i = 0; i < col->size; ++i)
                {
                    if (col->data[i] == x)
                    {
                        ++occurence;
                    }
                }

            case CHAR:
                for (int i = 0; i < col->size; ++i)
                {
                    if (((char*)(col->data))[i] == *((char*)x))
                    {
                        ++occurence;
                    }
                }

            case UINT:
                for (int i = 0; i < col->size; ++i)
                {
                    if (((unsigned int*)(col->data))[i] == *((unsigned int*)x))
                    {
                        ++occurence;
                    }
                }

            case INT:
                for (int i = 0; i < col->size; ++i)
                {
                    if (((int*)(col->data))[i] == *((int*)x))
                    {
                        ++occurence;
                    }
                }
                break;
            case FLOAT:
                for (int i = 0; i < col->size; ++i)
                {
                    if (((float*)(col->data))[i] == *((float*)x))
                    {
                        ++occurence;
                    }
                }
                break;
            case DOUBLE:
                for (int i = 0; i < col->size; ++i)
                {
                    if (((double*)(col->data))[i] == *((double*)x))
                    {
                        ++occurence;
                    }
                }
                break;
            case STRING:
                for (int i = 0; i < col->size; ++i)
                {
                    if (strcmp(((char**)(col->data))[i], (char*)x) == 0)
                    {
                        ++occurence;
                    }
                }
                break;
            default:
                break;
        }
    }
    return occurence;
}

// Retourner la valeur présente à la position x (x donné en paramètre)
COL_TYPE get_value_at(COLUMN *col, unsigned int x)
{
    COL_TYPE null_value;
    memset(&null_value, 0, sizeof(null_value)); // Initialiser null_value à 0

    if (col == NULL || x >= col->size) {
        return null_value; // Retourner une valeur nulle si la colonne est invalide ou si x est hors limites
    }

    return *(col->data[x]);
}

// Retourner le nombre de valeurs qui sont supérieures à x (x donné en paramètre)
int count_values_greater_than(COLUMN *col, COL_TYPE x) {
    if (col == NULL) {
        return 0; // Retourner 0 si la colonne est invalide
    }

    int count = 0;
    for (unsigned int i = 0; i < col->size; ++i) {
        switch (col->column_type) {
            case UINT:
                if (col->data[i]->uint_value > x.uint_value) {
                    ++count;
                }
                break;
            case INT:
                if (col->data[i]->int_value > x.int_value) {
                    ++count;
                }
                break;
            case CHAR:
                if (col->data[i]->char_value > x.char_value) {
                    ++count;
                }
                break;
            case FLOAT:
                if (col->data[i]->float_value > x.float_value) {
                    ++count;
                }
                break;
            case DOUBLE:
                if (col->data[i]->double_value > x.double_value) {
                    ++count;
                }
                break;
            default:
                break; // Autres types non pris en charge
        }
    }
    return count;
}

// Retourner le nombre de valeurs qui sont inférieures à x (x donné en paramètre)
int count_values_less_than(COLUMN *col, COL_TYPE x)
{
    if (col == NULL) {
        return 0; // Retourner 0 si la colonne est invalide
    }

    int count = 0;
    for (unsigned int i = 0; i < col->size; ++i) {
        switch (col->column_type) {
            case UINT:
                if (col->data[i]->uint_value < x.uint_value) {
                    ++count;
                }
                break;
            case INT:
                if (col->data[i]->int_value < x.int_value) {
                    ++count;
                }
                break;
            case CHAR:
                if (col->data[i]->char_value < x.char_value) {
                    ++count;
                }
                break;
            case FLOAT:
                if (col->data[i]->float_value < x.float_value) {
                    ++count;
                }
                break;
            case DOUBLE:
                if (col->data[i]->double_value < x.double_value) {
                    ++count;
                }
                break;
            default:
                break; // Autres types non pris en charge
        }
    }
    return count;
}

// Retourner le nombre de valeurs qui sont égales à x (x donné en paramètre)
int count_values_equal_to(COLUMN *col, COL_TYPE x)
{
    if (col == NULL) {
        return 0; // Retourner 0 si la colonne est invalide
    }

    int count = 0;
    for (unsigned int i = 0; i < col->size; ++i) {
        switch (col->column_type) {
            case UINT:
                if (col->data[i]->uint_value == x.uint_value) {
                    ++count;
                }
                break;
            case INT:
                if (col->data[i]->int_value == x.int_value) {
                    ++count;
                }
                break;
            case CHAR:
                if (col->data[i]->char_value == x.char_value) {
                    ++count;
                }
                break;
            case FLOAT:
                if (col->data[i]->float_value == x.float_value) {
                    ++count;
                }
                break;
            case DOUBLE:
                if (col->data[i]->double_value == x.double_value) {
                    ++count;
                }
                break;
            default:
                break; // Autres types non pris en charge
        }
    }
    return count;
}


COLUMN** create_empty_CDataframe()
{
    printf("Empty Dataframe\n");
    printf("Colum : []\n");
    printf("Index []\n");
    return NULL;
}

size_t get_type_size(ENUM_TYPE type)
{
    switch (type)
    {
        case NULLVAL:
            return sizeof(unsigned int);
        case UINT:
            return sizeof(unsigned int);
        case INT:
            return sizeof(int);
        case CHAR:
            return sizeof(char);
        case FLOAT:
            return sizeof(float);
        case DOUBLE:
            return sizeof(double);
        case STRING:
            return sizeof(char*);
        case STRUCTURE:
            return sizeof(void*); // Taille non spécifiée pour une structure
    }
    return 0; // Retourner 0 pour les types non pris en charge
}

void fill_empty_cells(COLUMN** CDataframe, int nombre_de_colonnes)
{
    // Trouver la taille physique maximale parmi toutes les colonnes
    size_t max_t_phy = 0;
    for (int i = 0; i < nombre_de_colonnes; ++i) {
        if (CDataframe[i]->max_size > max_t_phy) {
            max_t_phy = CDataframe[i]->max_size;
        }
    }

    // Ajuster la taille physique de toutes les colonnes à la taille maximale
    for (int i = 0; i < nombre_de_colonnes; ++i) {
        if (CDataframe[i]->max_size < max_t_phy) {
            CDataframe[i]->data = realloc(CDataframe[i]->data, max_t_phy * sizeof(COL_TYPE*)); // Réallouer le tableau de données
            if (CDataframe[i]->data == NULL) {
                fprintf(stderr, "Erreur lors de la réallocation de mémoire pour la colonne %s.\n", CDataframe[i]->title);
                exit(EXIT_FAILURE);
            }
            CDataframe[i]->max_size = max_t_phy; // Mettre à jour la taille physique
        }
    }

    // Remplir les cellules vides en fonction du type de données
    for (int i = 0; i < nombre_de_colonnes; ++i) {
        size_t type_size = get_type_size(CDataframe[i]->column_type);
        switch (CDataframe[i]->column_type) {
            case NULLVAL:
                for (size_t j = CDataframe[i]->size; j < max_t_phy; ++j) {
                    *((void**)CDataframe[i]->data[j]) = NULL; // Remplir avec NULL
                }
                break;
            case UINT:
                for (size_t j = CDataframe[i]->size; j < max_t_phy; ++j) {
                    *((int*)CDataframe[i]->data[j]) = 0; // Remplir avec 0 pour les types entiers
                }
                break;
            case INT:
                for (size_t j = CDataframe[i]->size; j < max_t_phy; ++j) {
                    *((int*)CDataframe[i]->data[j]) = 0; // Remplir avec 0 pour les entiers
                }
                break;
            case FLOAT:
                for (size_t j = CDataframe[i]->size; j < max_t_phy; ++j) {
                    *((float*)CDataframe[i]->data[j]) = 0.0f; // Remplir avec 0.0 pour les flottants
                }
                break;
            case DOUBLE:
                for (size_t j = CDataframe[i]->size; j < max_t_phy; ++j) {
                    memset(CDataframe[i]->data[j], 0, type_size); // Remplir avec zéros
                }
                break;
            case CHAR:
                for (size_t j = CDataframe[i]->size; j < max_t_phy; ++j) {
                    *((char*)CDataframe[i]->data[j]) = '\0'; // Remplir avec caractère nul
                }
                break;
            case STRING:
                for (size_t j = CDataframe[i]->size; j < max_t_phy; ++j) {
                    *((char**)CDataframe[i]->data[j]) = strdup(""); // Remplir avec une chaîne vide
                }
                break;
            case STRUCTURE:
                for (size_t j = CDataframe[i]->size; j < max_t_phy; ++j) {
                    *((void**)CDataframe[i]->data[j]) = NULL; // Remplir avec NULL pour les structures
                }
                break;
            default:
                fprintf(stderr, "Type de données non pris en charge pour la colonne %s.\n", CDataframe[i]->title);
                exit(EXIT_FAILURE);
        }
    }
}

void remplissage_utilisateur(COLUMN **CDataframe, int nombre_de_colonnes) {
    // Demande à l'utilisateur de saisir les valeurs pour chaque colonne
    for (int i = 0; i < nombre_de_colonnes; ++i) {
        printf("Remplissage de la colonne %d avec des valeurs fournies par l'utilisateur :\n", i + 1);

        // Saisie du titre de la colonne
        char titre[MAX_STRING_LENGTH];
        printf("Entrer le titre de la colonne %d : ", i + 1);
        scanf("%s", titre);

        ENUM_TYPE d; // Utilisation du nouveau type ENUM_TYPE
        char type_input[20]; // Définir un tableau de caractères pour stocker l'entrée de l'utilisateur

        printf("Entrer le type de ses données (INT, FLOAT, DOUBLE, STRING, CHAR, UINT, STRUCTURE) : ");
        scanf("%s", type_input);

        // Convertir la chaîne en majuscules pour la comparaison
        for (int k = 0; type_input[k]; k++) {
            type_input[k] = toupper(type_input[k]);
        }

        // Comparer l'entrée avec les types attendus
        if (strcmp(type_input, "INT") == 0) {
            d = INT;
        } else if (strcmp(type_input, "FLOAT") == 0) {
            d = FLOAT;
        } else if (strcmp(type_input, "DOUBLE") == 0) {
            d = DOUBLE;
        } else if (strcmp(type_input, "STRING") == 0) {
            d = STRING;
        } else if (strcmp(type_input, "CHAR") == 0) {
            d = CHAR;
        } else if (strcmp(type_input, "UINT") == 0) {
            d = UINT;
        } else if (strcmp(type_input, "STRUCTURE") == 0) {
            d = STRUCTURE;
        } else {
            printf("Type de données non pris en charge. Utiliser INT, FLOAT, DOUBLE, STRING, CHAR, UINT ou STRUCTURE.\n");
            // Gérer le cas où le type n'est pas pris en charge
            return;
        }

        // Allouer de la mémoire pour le titre
        char *title = strdup(titre);
        if (title == NULL) {
            printf("Erreur lors de l'allocation de mémoire pour le titre.\n");
            return;
        }

        // Créer une nouvelle colonne
        CDataframe[i] = create_column(d, title);
        if (CDataframe[i] == NULL) {
            printf("Erreur lors de la création de la colonne.\n");
            free(title); // Libérer la mémoire allouée pour le titre
            return;
        }

        // Demander le nombre de valeurs pour la colonne
        int nb_valeurs;
        printf("Entrer le nombre de valeurs pour la colonne %d : ", i + 1);
        scanf("%d", &nb_valeurs);

        // Saisir les valeurs pour la colonne
        printf("Entrer les valeurs pour la colonne %d :\n", i + 1);
        for (int j = 0; j < nb_valeurs; ++j) {
            switch (d) {
                case INT: {
                    int valeur;
                    printf("Valeur %d : ", j + 1);
                    scanf("%d", &valeur);
                    insert_value(CDataframe[i], &valeur, CDataframe[i]->size);
                    break;
                }
                case FLOAT: {
                    float valeur;
                    printf("Valeur %d : ", j + 1);
                    scanf("%f", &valeur);
                    insert_value(CDataframe[i], &valeur, CDataframe[i]->size);
                    break;
                }
                case DOUBLE: {
                    double valeur;
                    printf("Valeur %d : ", j + 1);
                    scanf("%lf", &valeur);
                    insert_value(CDataframe[i], &valeur, CDataframe[i]->size);
                    break;
                }
                case STRING: {
                    char *valeur = malloc(MAX_STRING_LENGTH + 1); // Allouer de la mémoire pour la chaîne de caractères
                    if (valeur != NULL) {
                        printf("Valeur %d : ", j + 1);
                        scanf("%s", valeur);
                        insert_value(CDataframe[i], valeur, CDataframe[i]->size);
                    }
                    break;
                }
                case CHAR: {
                    char valeur;
                    printf("Valeur %d : ", j + 1);
                    scanf(" %c", &valeur); // Lire un caractère (avec un espace avant %c pour ignorer les espaces blancs)
                    insert_value(CDataframe[i], &valeur, CDataframe[i]->size);
                    break;
                }
                case UINT: {
                    unsigned int valeur;
                    printf("Valeur %d : ", j + 1);
                    scanf("%u", &valeur);
                    insert_value(CDataframe[i], &valeur, CDataframe[i]->size);
                    break;
                }
                case STRUCTURE: {
                    printf("La saisie des structures n'est pas prise en charge pour le moment.\n");
                    break;
                }
                default:
                    printf("Type de données non pris en charge pour la colonne %d.\n", i + 1);
                    return;
            }
        }

        // Remplir les cellules vides
        fill_empty_cells(CDataframe, nombre_de_colonnes);
    }
}


void remplissage_dur(COLUMN **CDataframe, int nombre_de_colonnes)
{
    // Initialiser le générateur de nombres aléatoires avec le temps actuel
    srand(time(NULL));

    // Tableau de titres aléatoires possibles
    char *titres[] = {
            "Age",
            "Taille",
            "Poids",
            "Score",
            "Nom",
            "Prénom",
            "ID"};

    // Remplissage en dur des valeurs pour chaque colonne
    for (int i = 0; i < nombre_de_colonnes; ++i)
    {
        // Générer un titre aléatoire
        int random_index = rand() % (sizeof(titres) / sizeof(titres[0]));
        char *titre = titres[random_index];

        printf("Remplissage en dur de la colonne %d (%s) avec des valeurs aléatoires :\n", i + 1, titre);

        ENUM_TYPE type;
        // Déterminer le type de données en fonction du titre de la colonne
        if (strcmp(titre, "Age") == 0 || strcmp(titre, "Taille") == 0 || strcmp(titre, "Poids") == 0 || strcmp(titre, "Score") == 0 || strcmp(titre, "ID") == 0)
        {
            type = INT;
        }
        else if (strcmp(titre, "Nom") == 0 || strcmp(titre, "Prénom") == 0)
        {
            type = STRING;
        }
        else if (strcmp(titre, "Note") == 0)
        {
            type = FLOAT;
        }
        else if (strcmp(titre, "Revenue") == 0)
        {
            type = DOUBLE;
        }
        else if (strcmp(titre, "Données") == 0)
        {
            type = STRUCTURE;
        }
        else
        {
            printf("Type de données non pris en charge pour la colonne %s.\n", titre);
            continue;
        }
        char *title;
        CDataframe[i] = create_column(type, title);

        // Générer et insérer des valeurs aléatoires dans la colonne en fonction du type de données
        for (int j = 0; j < 100; ++j)
        {
            switch (type)
            {
                case INT:
                    for (int j = 0; j < 100; ++j) // Générer 100 valeurs aléatoires pour INT
                    {
                        int valeur = rand() % 100;
                        insert_value(CDataframe[i], &valeur,CDataframe[i]->size);
                    }
                    break;
                case STRING:
                    for (int j = 0; j < 100; ++j) // Générer 100 valeurs aléatoires pour STRING
                    {
                        char *valeur = malloc(MAX_STRING_LENGTH + 1); // Allouer de la mémoire pour la chaîne de caractères
                        if (valeur != NULL)
                        {
                            // Générer une chaîne de caractères aléatoire avec une longueur maximale définie
                            for (int k = 0; k < MAX_STRING_LENGTH; ++k)
                            {
                                valeur[k] = 'a' + rand() % 26; // Générer un caractère aléatoire entre 'a' et 'z'
                            }
                            valeur[MAX_STRING_LENGTH] = '\0'; // Ajouter le caractère de fin de chaîne
                            insert_value(CDataframe[i], valeur,CDataframe[i]->size);
                        }
                    }
                    break;
                case CHAR:
                    for (int j = 0; j < 100; ++j) // Générer 100 valeurs aléatoires pour CHAR
                    {
                        char valeur = 'a' + rand() % 26; // Générer un caractère aléatoire entre 'a' et 'z'
                        insert_value(CDataframe[i], &valeur,CDataframe[i]->size);
                    }
                    break;
                case UINT:
                    for (int j = 0; j < 100; ++j) // Générer 100 valeurs aléatoires pour UINT
                    {
                        unsigned int valeur = rand() % 100;
                        insert_value(CDataframe[i], &valeur,CDataframe[i]->size);
                    }
                    break;
                case STRUCTURE:
                    // Générer et insérer des valeurs aléatoires pour STRUCTURE
                    // À définir en fonction de la structure utilisée
                    break;
                default:
                    printf("Type de données non pris en charge pour la colonne %s.\n", CDataframe[i]->title);
                    break;
            }
        }
    }
}

void print_DataFrame(COLUMN **CDataframe, int nombre_de_colonnes)
{
    printf("test");
    // Vérification si le DataFrame est NULL
    if (CDataframe == NULL)
    {
        printf("Le DataFrame est NULL.\n");
        return;
    }

    // Déterminer la largeur maximale de chaque colonne pour l'alignement
    int *max_width = malloc(nombre_de_colonnes * sizeof(int));
    for (int i = 0; i < nombre_de_colonnes; ++i)
    {
        max_width[i] = strlen(CDataframe[i]->title);
        for (int j = 0; j < CDataframe[i]->size; ++j)
        {
            int width = 0;
            switch (CDataframe[i]->column_type)
            {
                case INT:
                    width = snprintf(NULL, 0, "%d", *((int *)(CDataframe[i]->data) + j));
                    break;
                case FLOAT:
                    width = snprintf(NULL, 0, "%.2f", *((float *)(CDataframe[i]->data) + j));
                    break;
                case DOUBLE:
                    width = snprintf(NULL, 0, "%.2lf", *((double *)(CDataframe[i]->data) + j));
                    break;
                case STRING:
                    width = strlen(*((char **)(CDataframe[i]->data) + j));
                    break;
                case CHAR:
                    width = 1; // Un caractère prend une largeur de 1
                    break;
                case UINT:
                    width = snprintf(NULL, 0, "%u", *((unsigned int *)(CDataframe[i]->data) + j));
                    break;
                case STRUCTURE:
                    width = sizeof(void *); // Taille d'un pointeur
                    break;
                default:
                    break;
            }
            if (width > max_width[i])
                max_width[i] = width;
        }
    }

    // Imprimer les bordures supérieures
    printf("+");
    for (int i = 0; i < nombre_de_colonnes; ++i)
    {
        for (int j = 0; j < max_width[i] + 2; ++j)
        {
            printf("-");
        }
        printf("+");
    }
    printf("\n");

    // Imprimer les titres des colonnes
    printf("|");
    for (int i = 0; i < nombre_de_colonnes; ++i)
    {
        printf(" %-*s |", max_width[i], CDataframe[i]->title);
    }
    printf("\n");

    // Imprimer les bordures intermédiaires
    printf("+");
    for (int i = 0; i < nombre_de_colonnes; ++i)
    {
        for (int j = 0; j < max_width[i] + 2; ++j)
        {
            printf("-");
        }
        printf("+");
    }
    printf("\n");

    int max_val = CDataframe[0]->size;
    for (int i = 1; i < nombre_de_colonnes; ++i)
    {
        if(max_val < CDataframe[i]->size)
            max_val = CDataframe[i]->size;
    }

    // Imprimer les valeurs
    for (int row = 0; row < max_val; ++row)
    {
        printf("|");
        for (int col = 0; col < nombre_de_colonnes; ++col)
        {
            char str[20];
            switch (CDataframe[col]->column_type)
            {
                case INT:
                    if (*((int*)(CDataframe[col]->data) + row) != INT_MAX)
                        printf(" %-*d |", max_width[col], *((int *)(CDataframe[col]->data) + row));
                    else
                        printf(" %-*s |", max_width[col], "null");
                    break;
                case FLOAT:
                    if (*((float*)(CDataframe[col]->data) + row) != FLT_MAX)
                        printf(" %-*.*f |", max_width[col], 2, *((float *)(CDataframe[col]->data) + row));
                    else
                        printf(" %-*s |", max_width[col], "null");
                    break;
                case DOUBLE:
                    if (*((double*)(CDataframe[col]->data) + row) != DBL_MAX)
                        printf(" %-*.*lf |", max_width[col], 2, *((double *)(CDataframe[col]->data) + row));
                    else
                        printf(" %-*s |", max_width[col], "null");
                    break;
                case STRING:
                    if (strlen(*((char **)(CDataframe[col]->data) + row)) == 0)
                        printf(" %-*s |", max_width[col], *((char **)(CDataframe[col]->data) + row));
                    else
                        printf(" %-*s |", max_width[col], "null");
                    break;
                case CHAR:
                    printf(" %-*c |", max_width[col], *((char *)(CDataframe[col]->data) + row));
                    break;
                case UINT:
                    if (*((unsigned int*)(CDataframe[col]->data) + row) != UINT_MAX)
                        printf(" %-*u |", max_width[col], *((unsigned int *)(CDataframe[col]->data) + row));
                    else
                        printf(" %-*s |", max_width[col], "null");
                    break;
                case STRUCTURE:
                    printf(" %-*p |", max_width[col], *((void **)(CDataframe[col]->data) + row));
                    break;
                default:
                    break;
            }
        }
        printf("\n");
    }

    // Imprimer les bordures inférieures
    printf("+");
    for (int i = 0; i < nombre_de_colonnes; ++i)
    {
        for (int j = 0; j < max_width[i] + 2; ++j)
        {
            printf("-");
        }
        printf("+");
    }
    printf("\n");

    // Libérer la mémoire allouée pour max_width
    free(max_width);
}

void print_partial_row_data(COLUMN** CDataframe, int nombre_de_colonnes, int start_index, int end_index)
{
    // Vérification si le DataFrame est NULL
    if (CDataframe == NULL)
    {
        printf("Le DataFrame est NULL.\n");
        return;
    }

    // Vérification des limites
    if (start_index < 0 || start_index >= end_index || end_index > CDataframe[0]->size)
    {
        printf("Limites invalides.\n");
        return;
    }

    // Déterminer la largeur maximale de chaque colonne pour l'alignement
    int *max_width = malloc(nombre_de_colonnes * sizeof(int));
    for (int i = 0; i < nombre_de_colonnes; ++i)
    {
        max_width[i] = strlen(CDataframe[i]->title);
        for (int j = start_index; j < end_index; ++j)
        {
            int width = 0;
            switch (CDataframe[i]->column_type)
            {
                case INT:
                    if (j < CDataframe[i]->size)
                        width = snprintf(NULL, 0, "%d", *((int *)(CDataframe[i]->data[j])));
                    break;
                case FLOAT:
                    if (j < CDataframe[i]->size)
                        width = snprintf(NULL, 0, "%.2f", *((float *)(CDataframe[i]->data[j])));
                    break;
                case DOUBLE:
                    if (j < CDataframe[i]->size)
                        width = snprintf(NULL, 0, "%.2lf", *((double *)(CDataframe[i]->data[j])));
                    break;
                case STRING:
                    if (j < CDataframe[i]->size)
                        width = strlen((char *)(CDataframe[i]->data[j]));
                    break;
                case CHAR:
                    width = 1; // Un caractère prend une largeur de 1
                    break;
                case UINT:
                    if (j < CDataframe[i]->size)
                        width = snprintf(NULL, 0, "%u", *((unsigned int *)(CDataframe[i]->data[j])));
                    break;
                case STRUCTURE:
                    // Adaptation nécessaire selon la structure de vos données
                    break;
                default:
                    break;
            }
            if (width > max_width[i])
                max_width[i] = width;
        }
    }

    // Imprimer les bordures supérieures
    printf("+");
    for (int i = 0; i < nombre_de_colonnes; ++i)
    {
        for (int j = 0; j < max_width[i] + 2; ++j)
        {
            printf("-");
        }
        printf("+");
    }
    printf("\n");

    // Imprimer les titres des colonnes
    printf("|");
    for (int i = 0; i < nombre_de_colonnes; ++i)
    {
        printf(" %-*s |", max_width[i], CDataframe[i]->title);
    }
    printf("\n");

    // Imprimer les bordures intermédiaires
    printf("+");
    for (int i = 0; i < nombre_de_colonnes; ++i)
    {
        for (int j = 0; j < max_width[i] + 2; ++j)
        {
            printf("-");
        }
        printf("+");
    }
    printf("\n");

    // Imprimer les valeurs
    for (int row = start_index; row < end_index; ++row)
    {
        printf("|");
        for (int col = 0; col < nombre_de_colonnes; ++col)
        {
            switch (CDataframe[col]->column_type)
            {
                case INT:
                    if (row < CDataframe[col]->size)
                        printf(" %-*d |", max_width[col], *((int *)(CDataframe[col]->data[row])));
                    else
                        printf(" %-*s |", max_width[col], "null");
                    break;
                case FLOAT:
                    if (row < CDataframe[col]->size)
                        printf(" %-*.*f |", max_width[col], 2, *((float *)(CDataframe[col]->data[row])));
                    else
                        printf(" %-*s |", max_width[col], "null");
                    break;
                case DOUBLE:
                    if (row < CDataframe[col]->size)
                        printf(" %-*.*lf |", max_width[col], 2, *((double *)(CDataframe[col]->data[row])));
                    else
                        printf(" %-*s |", max_width[col], "null");
                    break;
                case STRING:
                    if (row < CDataframe[col]->size)
                        printf(" %-*s |", max_width[col], (char *)(CDataframe[col]->data[row]));
                    else
                        printf(" %-*s |", max_width[col], "null");
                    break;
                case CHAR:
                    if (row < CDataframe[col]->size)
                        printf(" %-*c |", max_width[col], *((char *)(CDataframe[col]->data[row])));
                    else
                        printf(" %-*s |", max_width[col], "null");
                    break;
                case UINT:
                    if (row < CDataframe[col]->size)
                        printf(" %-*u |", max_width[col], *((unsigned int *)(CDataframe[col]->data[row])));
                    else
                        printf(" %-*s |", max_width[col], "null");
                    break;
                case STRUCTURE:
                    // Adaptation nécessaire selon la structure de vos données
                    break;
                default:
                    break;
            }
        }
        printf("\n");
    }

    // Imprimer les bordures inférieures
    printf("+");
    for (int i = 0; i < nombre_de_colonnes; ++i)
    {
        for (int j = 0; j < max_width[i] + 2; ++j)
        {
            printf("-");
        }
        printf("+");
    }
    printf("\n");

    // Libérer la mémoire allouée pour max_width
    free(max_width);
}

void print_partial_column_data(COLUMN **CDataframe, int nombre_de_colonnes, int start_index, int end_index)
{
    // Vérification si le DataFrame est NULL
    if (CDataframe == NULL)
    {
        printf("Le DataFrame est NULL.\n");
        return;
    }

    // Vérification des limites
    if (start_index < 0 || start_index >= end_index || end_index > CDataframe[0]->size)
    {
        printf("Limites invalides.\n");
        return;
    }

    printf("Affichage des colonnes de %d à %d :\n", start_index, end_index - 1);

    // Calcul de la largeur de chaque colonne
    int *largeur_colonne = (int*)malloc(nombre_de_colonnes * sizeof(int));
    for (int j = start_index; j < end_index; ++j)
    {
        largeur_colonne[j] = strlen(CDataframe[j]->title) + 2; // Ajouter 2 pour l'espace autour du titre
        for (int i = 0; i < CDataframe[j]->size; ++i)
        {
            int width = 0;
            switch (CDataframe[j]->column_type)
            {
                case INT:
                    if (i < CDataframe[j]->size)
                        width = snprintf(NULL, 0, "%d", *((int *)(CDataframe[j]->data[i])));
                    break;
                case FLOAT:
                    if (i < CDataframe[j]->size)
                        width = snprintf(NULL, 0, "%.2f", *((float *)(CDataframe[j]->data[i])));
                    break;
                case DOUBLE:
                    if (i < CDataframe[j]->size)
                        width = snprintf(NULL, 0, "%.2lf", *((double *)(CDataframe[j]->data[i])));
                    break;
                case STRING:
                    if (i < CDataframe[j]->size)
                        width = strlen((char *)(CDataframe[j]->data[i]));
                    break;
                case CHAR:
                    width = 1; // Un caractère prend une largeur de 1
                    break;
                case UINT:
                    if (i < CDataframe[j]->size)
                        width = snprintf(NULL, 0, "%u", *((unsigned int *)(CDataframe[j]->data[i])));
                    break;
                case STRUCTURE:
                    // Adaptation nécessaire selon la structure de vos données
                    break;
                default:
                    break;
            }
            if (width > largeur_colonne[j])
                largeur_colonne[j] = width;
        }
    }

    // Affichage de la bordure supérieure
    printf("+");
    for (int j = start_index; j < end_index; ++j)
    {
        for (int k = 0; k < largeur_colonne[j]; ++k)
        {
            printf("-");
        }
        printf("+");
    }
    printf("\n");

    // Affichage des titres des colonnes
    printf("|");
    for (int j = start_index; j < end_index; ++j)
    {
        printf(" %-*s|", largeur_colonne[j] - 2, CDataframe[j]->title);
    }
    printf("\n");

    // Affichage de la ligne de séparation
    printf("+");
    for (int j = start_index; j < end_index; ++j)
    {
        for (int k = 0; k < largeur_colonne[j]; ++k)
        {
            printf("-");
        }
        printf("+");
    }
    printf("\n");

    // Affichage des données des colonnes
    for (int i = 0; i < CDataframe[0]->size; ++i)
    {
        printf("|");
        for (int j = start_index; j < end_index; ++j)
        {
            switch (CDataframe[j]->column_type)
            {
                case INT:
                    if (i < CDataframe[j]->size)
                        printf(" %-*d|", largeur_colonne[j] - 2, *((int *)(CDataframe[j]->data[i])));
                    else
                        printf(" %-*s|", largeur_colonne[j] - 2, "null");
                    break;
                case FLOAT:
                    if (i < CDataframe[j]->size)
                        printf(" %-*.*f|", largeur_colonne[j] - 2, 2, *((float *)(CDataframe[j]->data[i])));
                    else
                        printf(" %-*s|", largeur_colonne[j] - 2, "null");
                    break;
                case DOUBLE:
                    if (i < CDataframe[j]->size)
                        printf(" %-*.*lf|", largeur_colonne[j] - 2, 2, *((double *)(CDataframe[j]->data[i])));
                    else
                        printf(" %-*s|", largeur_colonne[j] - 2, "null");
                    break;
                case STRING:
                    if (i < CDataframe[j]->size)
                        printf(" %-*s|", largeur_colonne[j] - 2, (char *)(CDataframe[j]->data[i]));
                    else
                        printf(" %-*s|", largeur_colonne[j] - 2, "null");
                    break;
                case CHAR:
                    if (i < CDataframe[j]->size)
                        printf(" %-*c|", largeur_colonne[j] - 2, *((char *)(CDataframe[j]->data[i])));
                    else
                        printf(" %-*s|", largeur_colonne[j] - 2, "null");
                    break;
                case UINT:
                    if (i < CDataframe[j]->size)
                        printf(" %-*u|", largeur_colonne[j] - 2, *((unsigned int *)(CDataframe[j]->data[i])));
                    else
                        printf(" %-*s|", largeur_colonne[j] - 2, "null");
                    break;
                case STRUCTURE:
                    // Adaptation nécessaire selon la structure de vos données
                    break;
                default:
                    break;
            }
        }
        printf("\n");
    }

    // Affichage de la bordure inférieure
    printf("+");
    for (int j = start_index; j < end_index; ++j)
    {
        for (int k = 0; k < largeur_colonne[j]; ++k)
        {
            printf("-");
        }
        printf("+");
    }
    printf("\n");

    // Libération de la mémoire
    free(largeur_colonne);
}

void delete_row(COLUMN** CDataframe, int nombre_de_colonnes, int index)
{
    if (CDataframe == NULL || index < 0) {
        printf("Paramètres non valides.\n");
        return;
    }

    // Vérifier que l'index est valide pour toutes les colonnes
    for (int i = 0; i < nombre_de_colonnes; ++i) {
        if (CDataframe[i] == NULL) {
            printf("Indice de ligne invalide pour la colonne %s.\n", CDataframe[i]->title);
            return;
        }
    }

    // Supprimer la ligne pour chaque colonne
    for (int i = 0; i < nombre_de_colonnes; ++i) {
        // Supprimer la ligne en décalant les valeurs vers la gauche
        size_t s = get_type_size(CDataframe[i]->column_type);
        for (int j = index; j < CDataframe[i]->size - 1; ++j) {
            switch (CDataframe[i]->column_type) {
                case INT:
                    *((int*)(CDataframe[i]->data) + j) = *((int*)(CDataframe[i]->data) + (j + 1));
                    break;
                case FLOAT:
                    *((float*)(CDataframe[i]->data) + j) = *((float*)(CDataframe[i]->data) + (j + 1));
                    break;
                case DOUBLE:
                    *((double*)(CDataframe[i]->data) + j) = *((double*)(CDataframe[i]->data) + (j + 1));
                    break;
                case STRING:
                    strcpy(*((char**)(CDataframe[i]->data) + j), *((char**)(CDataframe[i]->data) + (j + 1)));
                    break;
                case STRUCTURE:
                    // Supposons que MyStruct soit votre structure définie.
                    // Vous devez copier chaque membre de la structure.
                    memcpy(((char*)(CDataframe[i]->data)) + j * s,
                           ((char*)(CDataframe[i]->data)) + (j + 1) * s,
                           s);
                    break;
                case NULLVAL:
                    // Rien à faire pour les pointeurs void.
                    break;
                case CHAR:
                    *((char*)(CDataframe[i]->data) + j) = *((char*)(CDataframe[i]->data) + (j + 1));
                    break;
                case UINT:
                    *((unsigned int*)(CDataframe[i]->data) + j) = *((unsigned int*)(CDataframe[i]->data) + (j + 1));
                    break;
                default:
                    printf("Type de données non pris en charge pour la colonne %s.\n", CDataframe[i]->title);
                    return;
            }
        }
        // Décrémenter le compteur de lignes
        --CDataframe[i]->size;

        // Réduire la taille physique du tableau si nécessaire
        if (CDataframe[i]->size < CDataframe[i]->max_size - REALOCSIZE) {
            int new_size = CDataframe[i]->size + REALOCSIZE;
            void* new_tab = realloc(CDataframe[i]->data, new_size * s);
            if (new_tab == NULL) {
                printf("Erreur lors de la réallocation de mémoire pour la colonne %s.\n", CDataframe[i]->title);
                return;
            }
            CDataframe[i]->data = new_tab;
            CDataframe[i]->max_size = new_size;
        }
    }
}

int max_logical_size(COLUMN **CDataframe, int nombre_de_colonnes)
{
    int max_size = 0;

    // Parcourir toutes les colonnes
    for (int i = 0; i < nombre_de_colonnes; ++i) {
        // Vérifier si la colonne est vide
        if (CDataframe[i]->size == 0) {
            return 0; // Si une colonne est vide, le DataFrame est vide
        }

        // Mettre à jour la taille logique maximale
        if (CDataframe[i]->size > max_size) {
            max_size = CDataframe[i]->size;
        }
    }

    return max_size;
}

void add_row(COLUMN** CDataframe, int nombre_de_colonnes, void** values)
{
    // Vérification des paramètres d'entrée
    if (CDataframe == NULL || values == NULL) {
        printf("Paramètres non valides.\n");
        return;
    }

    // Ajout des nouvelles valeurs à chaque colonne
    for (int i = 0; i < nombre_de_colonnes; ++i) {
        // Vérifier le type de la valeur
        if (values[i] == NULL) {
            printf("Valeur NULL pour la colonne %s.\n", CDataframe[i]->title);
            return;
        }

        size_t max_logical_size_value = max_logical_size(CDataframe, nombre_de_colonnes);
        // Insérer la valeur dans la colonne correspondante
        switch (CDataframe[i]->column_type) {
            case INT:
                if (!insert_value(CDataframe[i], (int*)values[i], max_logical_size_value)) {
                    printf("Erreur lors de l'insertion de valeurs dans la colonne %s.\n", CDataframe[i]->title);
                    // Annuler les opérations précédentes en cas d'erreur
                    for (int j = i - 1; j >= 0; --j) {
                        delete_row(CDataframe, nombre_de_colonnes, CDataframe[j]->size - 1);
                    }
                    return;
                }
                break;
            case FLOAT:
                if (!insert_value(CDataframe[i], (float*)values[i], max_logical_size_value)) {
                    printf("Erreur lors de l'insertion de valeurs dans la colonne %s.\n", CDataframe[i]->title);
                    // Annuler les opérations précédentes en cas d'erreur
                    for (int j = i - 1; j >= 0; --j) {
                        delete_row(CDataframe, nombre_de_colonnes, CDataframe[j]->size - 1);
                    }
                    return;
                }
                break;
            case DOUBLE:
                if (!insert_value(CDataframe[i], (double*)values[i], max_logical_size_value)) {
                    printf("Erreur lors de l'insertion de valeurs dans la colonne %s.\n", CDataframe[i]->title);
                    // Annuler les opérations précédentes en cas d'erreur
                    for (int j = i - 1; j >= 0; --j) {
                        delete_row(CDataframe, nombre_de_colonnes, CDataframe[j]->size - 1);
                    }
                    return;
                }
                break;
            case STRING:
                if (!insert_value(CDataframe[i], (char*)values[i], max_logical_size_value)) {
                    printf("Erreur lors de l'insertion de valeurs dans la colonne %s.\n", CDataframe[i]->title);
                    // Annuler les opérations précédentes en cas d'erreur
                    for (int j = i - 1; j >= 0; --j) {
                        delete_row(CDataframe, nombre_de_colonnes, CDataframe[j]->size - 1);
                    }
                    return;
                }
                break;
            case STRUCTURE:
                if (!insert_value(CDataframe[i], values[i], max_logical_size_value)) {
                    printf("Erreur lors de l'insertion de valeurs dans la colonne %s.\n", CDataframe[i]->title);
                    // Annuler les opérations précédentes en cas d'erreur
                    for (int j = i - 1; j >= 0; --j) {
                        delete_row(CDataframe, nombre_de_colonnes, CDataframe[j]->size - 1);
                    }
                    return;
                }
                break;
            case NULLVAL:
                // Insérer NULL dans la colonne
                if (!insert_value(CDataframe[i], NULL, max_logical_size_value)) {
                    printf("Erreur lors de l'insertion de valeurs dans la colonne %s.\n", CDataframe[i]->title);
                    // Annuler les opérations précédentes en cas d'erreur
                    for (int j = i - 1; j >= 0; --j) {
                        delete_row(CDataframe, nombre_de_colonnes, CDataframe[j]->size - 1);
                    }
                    return;
                }
                break;
            case CHAR:
                // Insérer le caractère values[i] dans la colonne
                if (!insert_value(CDataframe[i], (char*)values[i], max_logical_size_value)) {
                    printf("Erreur lors de l'insertion de valeurs dans la colonne %s.\n", CDataframe[i]->title);
                    // Annuler les opérations précédentes en cas d'erreur
                    for (int j = i - 1; j >= 0; --j) {
                        delete_row(CDataframe, nombre_de_colonnes, CDataframe[j]->size - 1);
                    }
                    return;
                }
                break;
            case UINT:
                // Insérer la valeur unsigned int dans la colonne
                if (!insert_value(CDataframe[i], (unsigned int*)values[i], max_logical_size_value)) {
                    printf("Erreur lors de l'insertion de valeurs dans la colonne %s.\n", CDataframe[i]->title);
                    // Annuler les opérations précédentes en cas d'erreur
                    for (int j = i - 1; j >= 0; --j) {
                        delete_row(CDataframe, nombre_de_colonnes, CDataframe[j]->size - 1);
                    }
                    return;
                }
                break;
            default:
                printf("Type de données non pris en charge pour la colonne %s.\n", CDataframe[i]->title);
                return;
        }

    }
}

void add_column(COLUMN*** CDataframe, int* nombre_de_colonnes, char* title, ENUM_TYPE type)
{
    // Vérifier si CDataframe est NULL
    if (*CDataframe == NULL) {
        printf("Le CDataframe est NULL.\n");
        return;
    }

    // Réallouer de la mémoire pour le tableau de pointeurs de colonnes
    *CDataframe = (COLUMN**)realloc(*CDataframe, (*nombre_de_colonnes + 1) * sizeof(COLUMN*));
    if (*CDataframe == NULL) {
        printf("Erreur lors de la réallocation de mémoire pour le CDataframe.\n");
        return;
    }

    // Allouer de la mémoire pour la nouvelle colonne
    (*CDataframe)[*nombre_de_colonnes] = (COLUMN*)malloc(sizeof(COLUMN));
    if ((*CDataframe)[*nombre_de_colonnes] == NULL) {
        printf("Erreur lors de l'allocation de mémoire pour la nouvelle colonne.\n");
        return;
    }

    // Initialiser la nouvelle colonne
    (*CDataframe)[*nombre_de_colonnes]->title = title;
    (*CDataframe)[*nombre_de_colonnes]->column_type = type;
    (*CDataframe)[*nombre_de_colonnes]->size = 0; // Aucune valeur présente initialement
    (*CDataframe)[*nombre_de_colonnes]->max_size = REALOCSIZE; // Réserver de l'espace initial
    (*CDataframe)[*nombre_de_colonnes]->data= NULL; // Aucune valeur initialement

    ++(*nombre_de_colonnes);

    printf("La colonne '%s' a été ajoutée avec succès.\n", title);
}

void delete_column_CDataframe(COLUMN*** CDataframe, int* nombre_de_colonnes, int index)
{
    // Vérification si CDataframe est NULL ou si l'index est hors limites
    if (*CDataframe == NULL || index < 0 || index >= *nombre_de_colonnes) {
        printf("Index invalide ou CDataframe est NULL.\n");
        return;
    }

    // Libérer la mémoire pour la colonne à supprimer
    free((*CDataframe)[index]->title);
    free((*CDataframe)[index]->data);
    free((*CDataframe)[index]);

    // Déplacer les colonnes suivantes pour remplir le trou
    for (int i = index; i < *nombre_de_colonnes - 1; ++i) {
        (*CDataframe)[i] = (*CDataframe)[i + 1];
    }

    // Réduire la taille du tableau de pointeurs de colonnes
    COLUMN** temp = (COLUMN**)realloc(*CDataframe, (*nombre_de_colonnes - 1) * sizeof(COLUMN*));
    if (temp == NULL && *nombre_de_colonnes > 1) {
        printf("Erreur lors de la réallocation de mémoire pour le CDataframe.\n");
        return;
    }

    *CDataframe = temp;
    --(*nombre_de_colonnes);

    printf("La colonne à l'index %d a été supprimée avec succès.\n", index);
}

void rename_column(COLUMN** CDataframe, int nombre_de_colonnes, int index, char* new_title)
{
    // Vérification si CDataframe est NULL ou si l'index est hors limites
    if (CDataframe == NULL || index < 0 || index >= nombre_de_colonnes) {
        printf("Index invalide ou CDataframe est NULL.\n");
        return;
    }

    // Libérer l'ancien titre de la colonne
    free(CDataframe[index]->title);

    // Allouer de la mémoire pour le nouveau titre
    CDataframe[index]->title = strdup(new_title);  // strdup alloue et copie la chaîne

    if (CDataframe[index]->title == NULL) {
        printf("Erreur lors de l'allocation de mémoire pour le nouveau titre.\n");
        return;
    }

    printf("La colonne à l'index %d a été renommée avec succès en '%s'.\n", index, new_title);
}

int value_exists_in_column(COLUMN* column, void* value)
{
    if (column == NULL || column->data == NULL) {
        return 0;  // La colonne est vide ou NULL
    }

    int size = column->size;  // Taille logique de la colonne

    switch (column->column_type) {
        case INT:
            for (int i = 0; i < size; ++i) {
                if (*((int*)column->data + i) == *((int*)value)) {
                    return 1;  // La valeur existe dans la colonne
                }
            }
            break;
        case FLOAT:
            for (int i = 0; i < size; ++i) {
                if (*((float*)column->data + i) == *((float*)value)) {
                    return 1;  // La valeur existe dans la colonne
                }
            }
            break;
        case DOUBLE:
            for (int i = 0; i < size; ++i) {
                if (*((double*)column->data + i) == *((double*)value)) {
                    return 1;  // La valeur existe dans la colonne
                }
            }
            break;
        case STRING:
            for (int i = 0; i < size; ++i) {
                if (strcmp(*((char**)column->data + i), (char*)value) == 0) {
                    return 1;  // La valeur existe dans la colonne
                }
            }
            break;
        case STRUCTURE:
            // Ajoutez le code pour comparer les valeurs de structure ici
            break;
        case NULLVAL:
            // Ajoutez le code pour comparer les pointeurs void ici
            break;
        case CHAR:
            // Comparaison des caractères
            for (int i = 0; i < size; ++i) {
                if (*((char*)column->data + i) == *((char*)value)) {
                    return 1;  // La valeur existe dans la colonne
                }
            }
            break;
        case UINT:
            // Comparaison des entiers non signés
            for (int i = 0; i < size; ++i) {
                if (*((unsigned int*)column->data + i) == *((unsigned int*)value)) {
                    return 1;  // La valeur existe dans la colonne
                }
            }
            break;
        default:
            printf("Type de données non pris en charge.\n");
            break;
    }

    return 0;  // La valeur n'existe pas dans la colonne
}

int value_exists_in_CDataframe(COLUMN** CDataframe, int nombre_de_colonnes, void* value)
{
    if (CDataframe == NULL || value == NULL) {
        printf("CDataframe est NULL ou la valeur est NULL.\n");
        return 0;
    }

    for (int i = 0; i < nombre_de_colonnes; ++i) {
        if (value_exists_in_column(CDataframe[i], value)) {
            return 1;  // La valeur existe dans au moins une colonne
        }
    }
    return 0;  // La valeur n'existe pas dans le CDataframe
}
